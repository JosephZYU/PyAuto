Check out difference since last committed version:

    ğŸ’² git diff
    

    

Un-do the difference (by checking out specific file):

    ğŸ’² git checkout calc.py
    
    ğŸ§ MUST include the checkout file in the end!
    
    ğŸ˜ Here the check out is NOT to switch branch, but to getting out of the calc.py working status and un-do any changes
    
    ğŸ‘€ We can further verify the "checkout" by using git status & git diff
    

    
    
What if messed up with our commit message ( - m "message" ):

    ğŸ¯ ONLY change the message without doing another commit:

    ğŸ’² git commit --amend -m "Completed Subtract Function"
    
    ğŸ›‘ NOTE: the hash will also change despite we're amending on the same commit
    

    

    
    
    ğŸ‘€ NOTE: the --amend option is to change the comments ONLY, and must be done before pushing to the remote Origin Main / Master
    

    
    ğŸ‘€ The above ğŸ‘† is the incorrect message for final commit
    
    After we run the --amend option, we can see the commit has been modified with the new comments ğŸ‘‡
    

    

What if we accidentally forget to include a file as part of our commit:

    ğŸ¬ Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits â°

    ğŸ’² git commit --amend
    
    ğŸ‘€ we're amending the file this time, do NOT add anything after the --amend
    
    ğŸ˜ ONLY perform this if you have not yet pushed to other people
    

    
    ğŸ’² git log --stat
    
    âš¡ğŸ§  show the details of our last commit
    
    ğŸ‘€ Now we can see the .gitignore file is part of the last combined commit
    
    ğŸ›‘ Also note that this hash is DIFFERENT - we're changing our Git history
    

    

ğŸŒŸ What if we want to move the whole commit to our feature branch instead of our MAIN branch:

    Optional - recall - create and switch to branch:

    ğŸ’² git branch {new branch}
    
    ğŸ’² git checkout {new branch}
    



    Perform Git cherry pick ğŸ’
    
    ğŸ¬ Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits â°
    
    ğŸ˜ Cherry pick will create a new commit based off of our original - DOES NOT delete the original after that cherry pick
    
    ğŸ‘€ type letter "q" directly to escape git log (:q)
    
    
    
    ğŸ¯ cherry-pick
    
    Step 1 of N: copy hash # from the MAIN branch 
    
    ğŸ’² git log
    
    ğŸ¤ 89540f449eadd22809503d186960095a9f32c523
    
    ğŸ˜ normally ğŸ¤ pick 5 to 7 (E.g. 89540f) characters will be fine
    

    
    
    Optional - confirm there is NO commit of our cherry pick (Initial Commit is when it set up)
    
    ğŸ’² git log
    

    
    
    Step 2 of N: checkout (switch to) our feature branch:
    
    ğŸ’² git checkout subtract-feature
    

    
    Step 3 of N: checkout (switch to) our feature branch ğŸ’
    
    ğŸ’² git cherry-pick 89540f
    
    ğŸ’² git cherry-pick 89540f449eadd22809503d186960095a9f32c523
    
    ğŸ‘€ Now we're "re-locate" our commit from MAIN branch to feature branch
    

    
    Step 4 of N: after the cherry-pick, we should then delete / reset the commit from the MAIN branch - never meant for the MAIN to begin with
    
    
        4.1 git reset --soft    Back 1-level to STAGING area    ğŸ‘
        4.2 git reset (mix - default)   Back 2-level to WORKING area    ğŸ‘Œ
        4.3 git reset hard  Factory Reset - abandon ALL works   âš 
        
    
    4.1 ğŸ¬ Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits â°
    
    ğŸ’² git reset --soft ff816f52
    
     $ git reset --soft {hash # of initial commit}
    
    ğŸ‘€ the --soft option {hash #} is the one we want to KEEP! KEEP! KEEP! And we shall get rid of whatever that's NOT included. (E.g. get rid of Completed Subtract Function)
    

    
    What's great about a "soft" reset is that: it will "down-grade" / "relocate" 1-level to our work back to the STAGING area
     - in which we will NEVER lose any of our work
    

    
    4.2 ğŸ¬ Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits â°
    
    ğŸ’² git reset ff816f52
    
     $ git reset {hash # of initial commit}
    
    ğŸ‘€ Use the default reset option simply put git reset without the --soft option
    
    ğŸ§ Now it will "down-grade" / "relocate" 2-level to our work back to the Working area
    

    
    4.3 ğŸ¬ Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits â°
    
    ğŸ›‘ Be cautious with git reset --hard ğŸ›‘:
    
        â—‹ It will match the exact state we were in at the hash # we specify ğŸ”ğŸ”
        â—‹ It will delete our previous changes âš 
    
    ğŸ’² git reset --hard ff816f52
    
     $ git reset --hard {hash # of initial commit}
    
    ğŸ§ NOTE: all related work has been delete - reset hard to "factory-origin" settings ğŸ‘‡
    

    

Get rid of ALL untracked files:

    ğŸ’² git clean -df
    
    âš¡ğŸ§ 
    
    ğŸ§ -d: get rid of any untracked directories
    ğŸ§ -f: get rid of any untracked files
    

    
ğŸŒŸ Retrieve git commands if you accidentally hard reset from above - potential life saverğŸ‘ğŸ‘ :

    ğŸ’² git reflog
    
    Shows exactly what we've doing so far
    

    
    ğŸ’² git checkout 89540f4
    
    ğŸ§ 89540f4 is the 7-digit hash # from the checkout command: 

    
    Now we can see the we have our changes back!
    
    This it the previous commit that we reset and get rid of
    

    
    ğŸ›‘ NOTE: we are now in a detached-trash state - which will be deleted if NOT saved
    

    
    ğŸ¯ save the detached into backup feature-branch
    
    ğŸ’² git branch backup
    
    NOTE: by running the ğŸ’² git branch backup: it will save the current state into the new branch all-in-one step!
    
    ğŸ˜ Now we can see it's still there - saved into backup
    

    
    Optional - double confirm the backup is saved
    

    
    
ğŸŒŸğŸ‘ What if you really want to un-do some commits while other people have pulled some changes:

    ğŸ¯ To revert the effect of some earlier commits
    
    ğŸ‘ Now whenever you push these changes and somebody else pulls those down their history is not going to be corrupted because all of this history is the same and all they're going to get is these are these new commits that undid those previous commits
    
    ğŸ‘€ It's NOT going to modify / delete any existing commits - it's ONLY creating new commits on top of those that completed un-do all changes >> our history remains intact
    
    âš¡ğŸ§  revert: whatever happened stay there - only undo with new commits

    ğŸ’² git revert 89540f4
    

    
    Optional - check if reverted âœ…
    

    
    ğŸ˜ pro-tips on checking the difference between 1 hash #
    
    ğŸ’² git diff 89540f4 b1b0430

ğŸ˜ BONUS - how to create file names with space in between:

	ğŸ±â€ğŸ’» https://askubuntu.com/a/636755 âœ…
	
	ğŸ˜ Use double-quotes "" in most cases ğŸ‘
	
	ğŸ’² touch "02. Common Mistakes and Bad Commits.txt" 
	
ğŸ’² touch 02.\ Common\ Mistakes\ and\ Bad\ Commits.txt
